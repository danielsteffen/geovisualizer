/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * VisualisationComponentPanel.java
 *
 * Created on 25.01.2011, 12:37:30
 */
package com.dfki.av.sudplan.ui.vis;

import com.dfki.av.sudplan.control.ComponentBroker;
import com.dfki.av.sudplan.util.EarthFlat;
import com.sun.j3d.loaders.Scene;
import com.sun.j3d.utils.behaviors.mouse.MouseRotate;
import com.sun.j3d.utils.behaviors.mouse.MouseTranslate;
import com.sun.j3d.utils.behaviors.mouse.MouseWheelZoom;
import com.sun.j3d.utils.behaviors.vp.OrbitBehavior;
import com.sun.j3d.utils.universe.SimpleUniverse;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GraphicsConfiguration;
import javax.media.j3d.AmbientLight;
import javax.media.j3d.Background;
import javax.media.j3d.BoundingBox;
import javax.media.j3d.BoundingSphere;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Canvas3D;
import javax.media.j3d.DirectionalLight;
import javax.media.j3d.Transform3D;
import javax.media.j3d.TransformGroup;
import javax.vecmath.Color3f;
import javax.vecmath.Point3d;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author Sebastian Puhl <sebastian.puhl@dfki.de>
 */
public class VisualisationComponentPanel extends javax.swing.JPanel implements VisualisationComponent {

    private final Logger logger = LoggerFactory.getLogger(VisualisationComponentPanel.class);
    private MouseWheelZoom zoomBehaviour;
    private MouseTranslate translationBehaviour;
    private MouseRotate rotationBehaviour;
    /*ToDo Sebastian Puhl <sebastian.puhl@dfki.de>: Not a perfect solution if the users leaves the sphere no control 
     *  will be possible
     */
    //ToDo Sebastian Puhl <sebastian.puhl@dfki.de>: seems it would be a good idea to define the earth as bounds
    private BoundingSphere behaviourBounding = new BoundingSphere(new Point3d(), 1000000.0);
    private BoundingSphere lightBounds = new BoundingSphere(new Point3d(), 1000000.0);
    private BoundingSphere backgroundBounds = new BoundingSphere(new Point3d(), 1000000.0);
    private SimpleUniverse universe;
    private BranchGroup sceneGraph;
    private final AmbientLight al = new AmbientLight(new Color3f(0.6f, 0.6f, 0.6f));
//    private Vector3d home = new Vector3d(16.0, 65.0, 5.0);
    private final Vector3d home = new Vector3d(2007.0, 6609.0, 800.0);
    private final GraphicsConfiguration config = SimpleUniverse.getPreferredConfiguration();
    private final Canvas3D canvas3D = new Canvas3D(config);

    /** Creates new form VisualisationComponentPanel */
    public VisualisationComponentPanel() {
        logger.debug("{} Constructor() call", VisualisationComponentPanel.class.toString());
        initComponents();
        createUniverse();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    mainPanel = new javax.swing.JPanel();

    setLayout(new java.awt.BorderLayout());

    mainPanel.setPreferredSize(new java.awt.Dimension(800, 600));
    mainPanel.setLayout(new java.awt.BorderLayout());
    add(mainPanel, java.awt.BorderLayout.CENTER);
  }// </editor-fold>//GEN-END:initComponents
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JPanel mainPanel;
  // End of variables declaration//GEN-END:variables

    private BranchGroup createSceneGraph() {
        BranchGroup sceneRoot = new BranchGroup();
        return sceneRoot;
    }

    private void createUniverse() {
        /*ToDo Sebastian Puhl <sebastian.puhl@dfki.de>: clipping should be handeld in general therefore it was set by
         * default to 10
         */
        universe = new SimpleUniverse(canvas3D);
        canvas3D.getView().setBackClipDistance(300);
        canvas3D.setPreferredSize(new Dimension(800, 600));
        mainPanel.add(canvas3D, BorderLayout.CENTER);
        sceneGraph = createSceneGraph();
        sceneGraph.setCapability(BranchGroup.ALLOW_CHILDREN_EXTEND);
        sceneGraph.setCapability(BranchGroup.ALLOW_CHILDREN_WRITE);
        sceneGraph.setCapability(BranchGroup.ALLOW_DETACH);
        setBackground();
        configureLight();
        createWorld();
//    loadASCGeom();
//    loadASCGeom2();
//    initNavigation();
        OrbitBehavior behaviour = new OrbitBehavior(canvas3D, OrbitBehavior.REVERSE_ALL);
        behaviour.setProportionalZoom(true);
        behaviour.setRotationCenter(new Point3d(2007.0, 6609.0, 0.0));
//        behaviour.setZoomFactor(2);
        behaviour.setSchedulingBounds(behaviourBounding);
        universe.getViewingPlatform().setViewPlatformBehavior(behaviour);
        // This will move the ViewPlatform back a bit so the
        // objects in the scene can be viewed.
//    universe.getViewingPlatform().setNominalViewingTransform();
        gotoToHome();
        universe.addBranchGraph(sceneGraph);
    }

    private void initNavigation() {
        // set up the mouse rotation behavior
        final TransformGroup vpTransformation = universe.getViewingPlatform().getViewPlatformTransform();
        rotationBehaviour = new MouseRotate(MouseTranslate.INVERT_INPUT);
        rotationBehaviour.setTransformGroup(vpTransformation);
        rotationBehaviour.setSchedulingBounds(behaviourBounding);
        // setFactor(x,y)  0 = disable
//    rotationBehaviour.setFactor(0,005);
        sceneGraph.addChild(rotationBehaviour);

        // set up the mouse translate
        translationBehaviour = new MouseTranslate();
        translationBehaviour.setTransformGroup(vpTransformation);
        translationBehaviour.setSchedulingBounds(behaviourBounding);
//    translationBehaviour.setFactor(0.0012, 0.0012);
        sceneGraph.addChild(translationBehaviour);

        // set up the mouse WHEEL zoom behavior
        zoomBehaviour = new MouseWheelZoom();
        zoomBehaviour.setTransformGroup(vpTransformation);
        zoomBehaviour.setSchedulingBounds(behaviourBounding);
//    zoomBehaviour.setFactor(0.05);
        sceneGraph.addChild(zoomBehaviour);
    }

    private void createWorld() {

//    Box world = new Box(40075016.6856f, 34261226.9711f, 1.0f, Box.GENERATE_NORMALS, worldAppearance);
        final EarthFlat earth =  new EarthFlat(ComponentBroker.getInstance().getScalingFactor());
        System.out.println("earth extends: "+earth.EARTH_EXTENDS);
        System.out.println("earth bounds: "+new BoundingBox(earth.getGeometry().getBounds()));
        Transform3D worldTransformation = new Transform3D();
        worldTransformation.setTranslation(new Vector3f(0.0f, 0.0f, -0.02f));
        TransformGroup worldGroup = new TransformGroup(
                worldTransformation);
        worldGroup.setCapability(TransformGroup.ALLOW_TRANSFORM_WRITE);        
        worldGroup.addChild(earth.getGeometry());        
        sceneGraph.addChild(worldGroup);
    }

    private void configureLight() {
        al.setInfluencingBounds(lightBounds);
        al.setCapability(DirectionalLight.ALLOW_STATE_WRITE);
        al.setCapability(DirectionalLight.ALLOW_STATE_READ);        
        sceneGraph.addChild(al);

        Color3f light1Color = new Color3f(0.9f, 0.9f, 0.9f);
        Vector3f light1Direction = new Vector3f(300.0f, 150.0f, -50.0f);
        DirectionalLight light1 = new DirectionalLight(light1Color, light1Direction);
        light1.setInfluencingBounds(lightBounds);
        sceneGraph.addChild(light1);
    }

    private void setBackground() {
        Background background = new Background(0f, 1f, 0f);
        background.setApplicationBounds(backgroundBounds);
        sceneGraph.addChild(background);
    }

//    private void loadASCGeom() {
//    try {
//      InputStream input = this.getClass().getClassLoader().getResourceAsStream("sodermalm_5m.asc");
////    InputStream input = this.getClass().getClassLoader().getResourceAsStream("basedem.asc");
//      InputStreamReader isr = new InputStreamReader(new BufferedInputStream(input));
//      ArcGridParser loader = new ArcGridParser(isr);
//      GeometryInfo geoInfo = loader.parseArcGrid();
//      logger.debug("coordinates length: "+geoInfo.getCoordinates().length);
//      geoInfo.compact();
//      NormalGenerator nGenerator = new NormalGenerator();
//      nGenerator.generateNormals(geoInfo);
//      Stripifier stripifier = new Stripifier();
//      stripifier.stripify(geoInfo);
//      Appearance landscapeAppearance = new Appearance();
//      PolygonAttributes pa = new PolygonAttributes();
//      pa.setCullFace(PolygonAttributes.CULL_NONE);
//      landscapeAppearance.setPolygonAttributes(pa);
//      Shape3D landscape = new Shape3D();
//      landscape.setCapability(Shape3D.ALLOW_GEOMETRY_WRITE);
//      landscape.setCapability(Shape3D.ALLOW_GEOMETRY_READ);
//      landscape.setCapability(Shape3D.ALLOW_APPEARANCE_OVERRIDE_WRITE);
//      landscape.setCapability(Shape3D.ALLOW_APPEARANCE_OVERRIDE_READ);
//      landscape.setCapability(Shape3D.ALLOW_APPEARANCE_WRITE);
//      landscape.setCapability(Shape3D.ALLOW_APPEARANCE_READ);
//      landscape.addGeometry(geoInfo.getIndexedGeometryArray());
//      landscape.setAppearance(landscapeAppearance);
//      sceneGraph.addChild(landscape);
//    } catch (Exception ex) {
//      logger.error("Error while building geometry: ", ex);
//    }
//    }
    @Override
    public void gotoToHome() {
        Transform3D viewTransformation = new Transform3D();
        viewTransformation.setTranslation(home);
        universe.getViewingPlatform().getViewPlatformTransform().setTransform(viewTransformation);
    }

//  private void loadASCGeom2() {
//    DEMLoader loader = new DEMLoader();
//    try {
//      Scene loadedScene = loader.load(new BufferedReader(
    //new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream("sodermalm_5m.asc"))));
////      Scene loadedScene = loader.load(new BufferedReader(
//    new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream("basedem.asc"))));
//      logger.debug("loadedScene"+loadedScene);
//      sceneGraph.addChild(loadedScene.getSceneGroup());
//    } catch (Exception ex) {
//      logger.error("Error while loading Asc geometry: ",ex);
//    }
//  }
    @Override
    public Component getDnDComponent() {
        return canvas3D;
    }

    @Override
    public void addContent(final Scene scene) {
        if (scene == null) {
            return;
        }
        sceneGraph.addChild(scene.getSceneGroup());
    }
}
