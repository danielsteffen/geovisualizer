/**
 * TFPVisSOSFunction.java
 *
 * Created by DFKI AV on 21.09.2012. Copyright (c) 2011-2012 DFKI GmbH,
 * Kaiserslautern. All rights reserved. Use is subject to license terms.
 */
package de.dfki.av.geovisualizer.core.functions.ui;

import de.dfki.av.geovisualizer.core.AbstractTransferFunctionPanel;
import de.dfki.av.geovisualizer.core.color.ColorPaletteFactory;
import de.dfki.av.geovisualizer.core.color.IColorPalette;
import de.dfki.av.geovisualizer.core.functions.NumberInterval;
import de.dfki.av.geovisualizer.core.functions.VisSOSFunction;
import java.awt.Color;
import java.awt.Component;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ExecutionException;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.InputVerifier;
import javax.swing.JComponent;
import javax.swing.JFormattedTextField;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JSpinner.DefaultEditor;
import javax.swing.JTextField;
import javax.swing.ListCellRenderer;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingWorker;
import javax.swing.border.Border;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.DefaultFormatter;
import org.openide.util.Exceptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Color panel for the SOS visualization.
 *
 * @author Tobias Zimmermann <tobias.zimmermann@dfki.de>
 */
public class TFPVisSOSFunction extends AbstractTransferFunctionPanel {

    /**
     * The logger.
     */
    private static final Logger LOG = LoggerFactory.getLogger(TFPVisSOSFunction.class);
    /**
     * The transfer function.
     */
    private final VisSOSFunction function;
    /**
     *
     */
    private ClassificationTableModel tableModel;
    private List<ImageIcon> icons;
    private final List<String> names;
    private ClassifyWorker worker;

    /**
     * Creates new form TFPVisSOSFunction
     */
    public TFPVisSOSFunction(final VisSOSFunction f) {
        initComponents();
        function = f;
        names = ColorPaletteFactory.getNames();
        icons = new ArrayList<>();
        int index = 0;
        for (Iterator<String> it = names.iterator(); it.hasNext();) {
            String colorPaletteName = it.next();
            colorPaletteComboBox.addItem(index);
            index++;
            icons.add(ColorPaletteFactory.newInstance(colorPaletteName).getIcon());
        }
        ComboBoxRenderer renderer = new ComboBoxRenderer();
        colorPaletteComboBox.setRenderer(renderer);
        colorPaletteComboBox.addItemListener(new ItemChangeListener());
        int selectedIndex = colorPaletteComboBox.getSelectedIndex();
        palette = ColorPaletteFactory
                .newInstance(names.get(selectedIndex));
        classCountSpinner.setModel(new SpinnerNumberModel(palette.getMaxNumColors(),
                palette.getMinNumColors(), palette.getMaxNumColors(), 1));
        ((DefaultEditor) classCountSpinner.getEditor()).getTextField()
                .setEditable(false);
        this.tableModel = new ClassificationTableModel();
        classTable.setDefaultRenderer(Color.class, new ColorRenderer(true));
        classTable.setModel(tableModel);
        classify();
        JComponent comp = classCountSpinner.getEditor();
        JFormattedTextField field = (JFormattedTextField) comp.getComponent(0);
        DefaultFormatter formatter = (DefaultFormatter) field.getFormatter();
        formatter.setCommitsOnValidEdit(true);
        classCountSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                classify();
            }
        });
        lowerBorderTextField.setInputVerifier(
                new BoundInputVerifier(upperBorderTextField, false));
        upperBorderTextField.setInputVerifier(
                new BoundInputVerifier(lowerBorderTextField, true));
        upperBorderTextField.addKeyListener(new ComponentKeyAdapter());
        lowerBorderTextField.addKeyListener(new ComponentKeyAdapter());
        upperBorderTextField.getDocument().addDocumentListener(
                new ComponentDocumentListener(upperBorderTextField));
        lowerBorderTextField.getDocument().addDocumentListener(
                new ComponentDocumentListener(lowerBorderTextField));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        attributeComboBox = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        colorPaletteComboBox = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        lowerBorderTextField = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        upperBorderTextField = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        classTable = new javax.swing.JTable();
        classCountSpinner = new javax.swing.JSpinner();

        attributeComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                attributeComboBoxActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.jLabel1.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel2, org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.jLabel2.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel3, org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.jLabel3.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel4, org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.jLabel4.text")); // NOI18N

        lowerBorderTextField.setText(org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.lowerBorderTextField.text")); // NOI18N

        org.openide.awt.Mnemonics.setLocalizedText(jLabel5, org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.jLabel5.text")); // NOI18N

        upperBorderTextField.setText(org.openide.util.NbBundle.getMessage(TFPVisSOSFunction.class, "TFPVisSOSFunction.upperBorderTextField.text")); // NOI18N

        classTable.setAutoCreateRowSorter(true);
        classTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN);
        classTable.setColumnSelectionAllowed(true);
        classTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(classTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 181, Short.MAX_VALUE)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(18, 18, 18))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(attributeComboBox, javax.swing.GroupLayout.Alignment.TRAILING, 0, 269, Short.MAX_VALUE)
                            .addComponent(colorPaletteComboBox, javax.swing.GroupLayout.Alignment.TRAILING, 0, 269, Short.MAX_VALUE)
                            .addComponent(lowerBorderTextField)
                            .addComponent(upperBorderTextField, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 269, Short.MAX_VALUE)
                            .addComponent(classCountSpinner, javax.swing.GroupLayout.Alignment.TRAILING))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(attributeComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(colorPaletteComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(classCountSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(lowerBorderTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(upperBorderTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 187, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(20, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void attributeComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_attributeComboBoxActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_attributeComboBoxActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox attributeComboBox;
    private javax.swing.JSpinner classCountSpinner;
    private javax.swing.JTable classTable;
    private javax.swing.JComboBox colorPaletteComboBox;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField lowerBorderTextField;
    private javax.swing.JTextField upperBorderTextField;
    // End of variables declaration//GEN-END:variables
    /**
     * Current selected {@link IColorPalette}
     */
    private IColorPalette palette;

    @Override
    public String getSelectedAttribute() {
        return (String) attributeComboBox.getSelectedItem();
    }

    @Override
    public boolean setAttributes(List<String[]> attributes) {
        for (Iterator<String[]> it = attributes.iterator(); it.hasNext();) {
            String[] attribute = it.next();
            if (!attribute[1].equalsIgnoreCase("String")) {
                attributeComboBox.addItem(attribute[0]);
            }
        }
        return attributeComboBox.getItemCount() > 0 ? true : false;
    }

    /**
     * Method which calculates the bounds of all classes and visualizes the
     * feedback in the UI.
     */
    private void classify() {
        if(worker != null){
            worker.cancel(true);
        }
        worker = new ClassifyWorker();
        worker.execute();
    }

    /**
     * Class which handles the item changed event of the combo box.
     */
    class ItemChangeListener implements ItemListener {

        @Override
        public void itemStateChanged(ItemEvent event) {
            if (event.getStateChange() == ItemEvent.SELECTED) {
                Object item = event.getItem();
                try {
                    int index = (Integer) item;
                    palette = ColorPaletteFactory
                            .newInstance(names.get(index));
                    classCountSpinner.setModel(new SpinnerNumberModel(palette.getMaxNumColors(),
                            palette.getMinNumColors(),
                            palette.getMaxNumColors(), 1));
                    ((DefaultEditor) classCountSpinner.getEditor()).getTextField()
                            .setEditable(false);
                    classify();
                } catch (ClassCastException ex) {
                    System.out.println(ex);
                }
            }
        }
    }

    class ComboBoxRenderer extends JLabel
            implements ListCellRenderer {

        public ComboBoxRenderer() {
            setOpaque(true);
            setHorizontalAlignment(LEFT);
            setVerticalAlignment(CENTER);
        }

        /*
         * This method finds the image and text corresponding
         * to the selected value and returns the label, set up
         * to display the text and image.
         */
        @Override
        public Component getListCellRendererComponent(
                JList list,
                Object value,
                int index,
                boolean isSelected,
                boolean cellHasFocus) {
            //Get the selected index. (The index param isn't
            //always valid, so just use the value.)
            int selectedIndex = ((Integer) value).intValue();

            if (isSelected) {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            } else {
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            }

            //Set the icon and text.  If icon was null, say so.
            ImageIcon icon = icons.get(selectedIndex);
            String itemName = names.get(selectedIndex);
            itemName = itemName
                    .replaceAll("de.dfki.av.geovisualizer.core.color.", "");
            itemName = itemName
                    .replaceAll(".java", "");
            setIcon(icon);
            if (icon != null) {
                setText(itemName);
                setFont(list.getFont());
            } else {
                setNoImageText(itemName + " (no image available)");
            }

            return this;
        }

        /**
         * Set text when no image was found.
         *
         */
        protected void setNoImageText(String text) {
            setText(text);
        }
    }

    class BoundInputVerifier extends InputVerifier {

        private JComponent intputBound;
        private final Border RED_BORDER = BorderFactory.createLineBorder(Color.red);
        private Border BORDER;
        private final Boolean upperBound;

        /**
         *
         * @param inputBound JTextField with other bound value.
         * @param upperBound true if input verifier will be attached to upper
         * bound.
         */
        public BoundInputVerifier(JComponent inputBound, Boolean upperBound) {
            this.intputBound = inputBound;
            this.upperBound = upperBound;
            this.BORDER = inputBound.getBorder();
        }

        @Override
        public boolean verify(JComponent input) {
            String text = null;
            String text2;
            double value2 = 0;
            double value = 0;
            try {
                text = ((JTextField) input).getText();
                try {
                    if (text != null) {
                        value = Double.valueOf(text);
                    }
                } catch (NumberFormatException e) {
                    input.setBorder(RED_BORDER);
                    return false;
                }
            } catch (ClassCastException ex) {
            }
            try {
                text2 = ((JTextField) intputBound).getText();
                try {
                    if (text2 != null) {
                        value2 = Double.valueOf(text2);
                    }
                } catch (NumberFormatException e) {
                }
            } catch (ClassCastException ex) {
                return true;
            }
            try {
                if (text != null && text2 != null) {
                    if (upperBound) {
                        if (value2 < value) {
                            input.setBorder(BORDER);
                            classify();
                            return true;
                        }
                    } else {
                        if (value < value2) {
                            input.setBorder(BORDER);
                            classify();
                            return true;
                        }
                    }
                }
            } catch (NumberFormatException e) {
            }
            input.setBorder(RED_BORDER);
            return false;
        }
    }

    class ClassifyWorker extends SwingWorker<Boolean, Void> {
        private Integer classCount;
        private double lowerBorder;
        private double upperBorder;

        @Override
        protected Boolean doInBackground() throws Exception {
            String lowerBorderString = lowerBorderTextField.getText();
            String upperBorderString = upperBorderTextField.getText();
            classCount = (Integer) classCountSpinner.getValue();
            lowerBorder = -100;
            upperBorder = 100;
            try {
                lowerBorder = Double.valueOf(lowerBorderString);
            } catch (NumberFormatException e) {
                lowerBorderTextField.setText(String.valueOf(lowerBorder));
            }
            try {
                upperBorder = Double.valueOf(upperBorderString);
            } catch (NumberFormatException e) {
                upperBorderTextField.setText(String.valueOf(upperBorder));
            }
            if (upperBorder > lowerBorder) {
                return true;
            }
            return false;
        }

        @Override
        protected void done() {
            try {
                if (get()) {
                    double range = upperBorder - lowerBorder;
                    double step = range / (double) classCount;
                    function.clear();
                    if (tableModel.getRowCount() > 0) {
                        try {
                            tableModel.removeAllRows();
                        } catch (IndexOutOfBoundsException e) {
                            // TODO
                        }
                    }
                    List<Color> cList = palette.getColors(classCount);
                    for (int i = 0; i < classCount; i++) {
                        double start = lowerBorder + step * i;
                        double end = lowerBorder + step * (i + 1);
                        NumberInterval n = new NumberInterval(start, end);
                        Color c = cList.get(i);
                        function.addClassification(n, c);
                        Object[] classdef = new Object[4];
                        classdef[0] = String.valueOf(start);
                        classdef[1] = String.valueOf(end);
                        classdef[2] = new Color(c.getRed(), c.getGreen(), c.getBlue());
                        tableModel.addRow(classdef);
                    }
                }
            } catch (InterruptedException ex) {
                Exceptions.printStackTrace(ex);
            } catch (ExecutionException ex) {
                Exceptions.printStackTrace(ex);
            }
        }
    }
}
